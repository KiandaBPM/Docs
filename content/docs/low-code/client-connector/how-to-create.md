---
title: "How to create a Client Connector"
linkTitle: "How to create"
weight: 1
typora-root-url: ..\..\..\..\static
toc_hide: false
hide_summary: false
---

# Introduction 

This section will detail how to create a new **Client Connector** which is a customised data connector for your organisation. You may wish to create a test connector to begin with by following the steps below using the demo code provided. More detail will be provided in the how-to-use section.

**Note:** You must be have an **Administrator** or **Developer** role to create a client connector.

## Before you begin

Please note before you begin that there are three key steps that need to be implemented in order to create and use a customised connector. 

1. Microservice - create a **microservice** or use an existing service to perform a metadata query and test actions, click on the [Microservice](/docs/low-code/client-connector/create-microservice/) link to get further details.

2. Use Kianda features to create and test your customised connector - use **Developer** to [create a new connector](#create-a-new-connector) and use **Data sources** to [create a connector datasource](#create-a-connector-datasource) for the newly customised connector.

3. Process - use the custom connector to bring data into a process and use the query hook to filter the data.

   

## Create a new connector

To create a new customised connector, follow the steps below:

1. From the left-hand **side menu**, go to **Administration** > **Developer** then within the **Connectors** panel click on **New Connector**.

![New Connector](/images/new-connector.jpg)

2. In the **Create Connector** dialog box, add a **Title** and browse for an **Icon URL** for your connector. The **Connector Unique ID** is automatically generated by the system. 

   ![Create connector dialog box](/images/create-connector.jpg)

3. Make sure to **copy the secret key** to a safe location where you will find it as it will be needed later. You can do this by a) clicking on **Download TXT** which will result in the Secret Key being downloaded as a CSV file or b) clicking on **Copy Key to Clipboard**, then click on **OK** when done. 

4. After populating the initial dialog box, the next screen will show you the title of the connector and contains four tabs: [Connector Settings](#connector-settings-tab), [Settings UI](#settings-ui-tab), [Settings Code](#settings-code-tab) and [Query Code](#query-code-tab).

   ![Tabs to create a customised connector](/images/connector-settings-demo.jpg)

   The details of these tabs are found in the following sections.

### Connector Settings tab

This is where the Connector **Title** and **Icon** can be changed. These details will be seen in the [Data connectors](/docs/platform/connectors/) function, once the customised connector is created. The URL for metadata, test and query can be edited here too. The Metadata, Test and Query URL's can be populated when the microservice is created, see [Create a Microservice](/docs/low-code/client-connector/create-microservice/) link for more details.

To save details click on **Update**, then click on **Close** to return to the **Developer resources** page.

### Settings UI tab
The **Settings UI** sets the user interface for a customised data connector within the **Data sources** function, found within **Administration** in the left-hand pane. By default there is sample code in this tab. This code will be rendered when the datasource for this connector is activated. 

   ```HTML
   <div class="form-group">
     <label class="control-label">Client Key</label>
     {{input type="text" value=datasource.clientkey class="form-control"}}
   </div>
   
   <div class="form-group">
     <label class="control-label">Environment</label>
     {{radio-button default=true name='environment' label='Demo' value='demo' group=datasource.settings.environment}}
     {{radio-button name='environment' label='Live' value='live' group=datasource.settings.environment}}
   </div>
   
   <div class="form-group">
     <button type="button" class="btn btn-primary" {{action 'authorize'}}>
       {{#if datasource.settings.authorized}}
         Re-Authorize
       {{else}}
         Authorize
       {{/if}}
     </button>
   </div>
   ```

This code creates the content on the screen seen below, available in the **Data sources** function on the **Datasource details** page, within the class **form-group** listed in the code above there is an **Environment** setting with labels 'Demo' and 'Live' which can be seen in the screen below. Also note an **Authorize** button added in the code above which has an action **'authorize'** which is handled by the code in the [Settings Code tab](#settings-code-tab).

![Datasources details created from Settings UI tab](/images/settings-ui-datasources.jpg)

Other details on the screen above, like the name of the page **Datasource details**, **Use Kianda Cloud Connect** and buttons **Test connection**, **Save**, **Security** and **Close** are automatically part of the UI for customised data connectors. However, custom handlebars can be added for the **settings** of the connector datasource using code in the **Settings UI** tab, namely fields like **Datasource Name** and **Client Key** as shown in the image above. This principles works the same **Widget UI** seen when creating custom [rule widgets](/docs/low-code/rule-widget/) or [field widgets](/docs/low-code/field-widget/) for example.

### Settings Code ###

In a similar manner to creating custom [rule widgets](/docs/low-code/rule-widget/) or [field widgets](/docs/low-code/field-widget/) where there are **Widget code** tabs, the connector widget has a tab called **Settings Code** which is used to create the JavaScript code for the settings UI.

By default there is code in this tab, for example the **Authorize** button shown in the **Datasource details** page above has an 'authorize' function which is the first segment of code below. As this sample code, 'OAuth playground' is used as a sandbox.

```JavaScript
{
  actions: {
    authorize() {
      var that = this;
      var isDemo=this.get("datasource.settings.environment")==='demo';
      let authUrl= 'https://www.oauth.com/playground/auth-dialog.html?';
      let consenturl = authUrl +  'response_type=code'
                                +  '&client_id='+this.get("datasource.settings.clientkey")
                                +  '&redirect_uri=https://app.kianda.com/index.html'
                                +  '&scope=photo+offline_access'
                                +  '&state=t4kBXKDIJc4X4gf2';
      var authWindow = window.open(consenturl, '_blank', 'height=500,width=700,scrollbars=yes,location=yes');

      try {
        authWindow.focus();
      } catch (e) {
        $.notify('Error during authentication, please try again', {
        status: 'warning'
        });
      }

      var handleCallback = function (evt) {
        if(that.isDestroyed !== true && evt.origin.indexOf('kianda.com') > -1 && evt.data){
            let accessCode = evt.data;

            let scope = "photo+offline_access";

            that.set('datasource.settings.accessCode', accessCode);
            that.set('datasource.settings.accessToken', null);
            that.set('datasource.settings.refreshToken', null);
            that.set('datasource.settings.authorized', false);
            that.set("datasource.settings.scope", scope);
            that.datasource.save().then(function () {
              that.sendAction('test', that.datasource);
            });
        }
        window.removeEventListener('message', handleCallback);
      };
      window.addEventListener('message', handleCallback, false);
    }
  }
}
```

Other aspects to note in this sample code are the datasource settings, for example `datasource.settings.accessToken` and  `datasource.settings.environment` denoting that you can add whatever **settings** you want to the UI within the **Datasources details** page using this type of code. These settings could be then used in a [Microservice](/docs/low-code/client-connector/create-microservice/) to create an action based on a chosen setting.

### Query Code ###

When using a data source, all data sources will have built-in **metadata**, **query** and **querySuccess** functions to allow content searches, including metadata content or information about the content, such as title, author and creation date. The **Query code** tab contains the code needed for these three functions. Default code is provided to help you get started, see below.

```javascript
{
  metaData(tree, datasource) {
    return tree;
  },
  query(datasource, query, rule, process) {
    if(query.conditions)
    {
      query.filter = query.conditions[0].conditions[0].arg2.value;
    }
    return query;
  },
  querySuccess(datasource,result,rule,process) {
    // this.get("dataservice").mapSuccess(result,rule,process); //uncomment to use default mapping behaviour
    return result;
  }
}
```

The default code contains three **hooks** that allow you to tap in to a module to trigger certain behaviours or actions. These hooks are: 

- [metaData hook](#metadata-hook)
- [Query hook](#query-hook)
- [querySuccess hook](#querysuccess-hook)

Click on each of the links above to see further details. 

In Ember, **bubbling** will search for each of the actions in the code above, and if not found, then a default action is used, but if found the default is overwritten. This principle is useful when something is created multiple times which is the case when creating custom data connectors.

#### metaData hook ####

The **Metadata hook** is where the return of the tree or metadata call can be altered for a chosen datasource used in Kianda form design.  

The **`tree`parameter** as part of this hook is seen in the sample code snippet below.

```javascript
  metaData(tree, datasource) {
    return tree;
  }
```

This **tree parameter** could be defined and structured as follows using nested objects 'Get Countries'  and 'Get Cities'  which are associated with **nodes** 'Country' and 'Country' and 'City'. See [Bootstrap Tree View package documentation](https://github.com/jonmiles/bootstrap-treeview#bootstrap-tree-view) for more details on hierarchical tree structures.

```json
tree:[
  {
    "name": "Get Countries",
    "text": "Get Countries",
    "title": "Get Countries",
    "icon": "fa fa-globe",
    "type": "STRUCTURE",
    "nodes": [
      {
        "name": "Country",
        "text": "Country",
        "title": "Country",
        "icon": "",
        "type": "text"
      }
    ],
    "fields": [
      {
        "name": "Country",
        "text": "Country",
        "title": "Country",
        "icon": "",
        "type": "text"
      }
    ],
    "selectable": true
  },
  {
    "name": "Get Cities",
    "text": "Get Cities",
    "title": "Get Cities",
    "icon": "fa fa-globe",
    "type": "STRUCTURE",
    "nodes": [
      {
        "name": "Country",
        "text": "Country",
        "title": "Country",
        "icon": "",
        "type": "text"
      },
      {
        "name": "City",
        "text": "City",
        "title": "City",
        "icon": "",
        "type": "text"
      }
    ],
    "fields": [
      {
        "name": "Country",
        "text": "Country",
        "title": "Country",
        "icon": "",
        "type": "text"
      },
      {
        "name": "City",
        "text": "City",
        "title": "City",
        "icon": "",
        "type": "text"
      }
    ],
    "selectable": true
  }
]
```

This structure will result in the output as shown in the image below, when a data source is chosen for use in form design that uses a new data connector called 'Demo Connector'. 

![Datasource tree and network tab](/images/trigger-tree-function-copy.jpg)

So when the data source is selected,  the tree function is triggered as seen in the **Network** tab calls. The function is queried and the response is rendered as a tree view in the **datasource tree** box in Kianda. 

The other parameter named in this **metadata hook**, namely `datasource` , defines properties used in the data connector settings like Title and Icon for the data connector.  A sample schema is available at [Datasource schema](/docs/low-code/client-connector/sample-schemas/#datasource-schema).

### Query Hook

The **Query hook** allows a query to the datasource to be customised. Parameters are passed into this function to allow customisation to happen. These parameters are: `datasource`, `query`, `rule` and `process`; sample schemas are available for each at the [Sample schema]() link.

```javascript
 query(datasource, query, rule, process) {
    if(query.conditions)
    {
      query.filter = query.conditions[0].conditions[0].arg2.value;
    }
    return query;
  }
```



We will use the countries and cities example scenario to explain the query hook, two list fields datasoure as the value have been set up in a process, the first list field will call the get countries function and when a user selects a country from the list the second list will have a condition to get the cities related to the selected country.

The below query hook takes in 4 parameters, [sample schemas are for each are available here](#sample-schemas).

Thinking of the scenario above when a list is populated from a datasource it needs to query the datasource each time, in a standard connector the query is handled by default but in this case the query is going to be handled using our custom connector. Using the passed in parameters we can check for various things such as rules and conditions. in the example below the filter will be captured by drilling into the query conditions and taking the value of the right hand argument or arg2, this should be the country that has been selected in the dropdown, by setting query.filter **we are altering the query before it is executed **. 

This ties in with the [query success hook](#querysuccess-hook) which handles the result which is returned from the datasource, which can also be customized. 

```javascript
query(datasource, query, rule, process)
{
	if(query.conditions)
    {
    	query.filter = query.conditions[0].conditions[0].arg2.value;
    }
  	return query;
}
```



### QuerySuccess hook

The idea of the query success hook is to be able to customize the response of a datasource query for example drill into a complicated json response based on a condition.  

```c#
querySuccess(datasource,result,rule,process) {
    // this.get("dataservice").mapSuccess(result,rule,process); //uncomment to use default mapping behaviour
   return result;
  }
```
Once the connector is created, the connector is available from the **Data sources** function under **Administration**, see next section for details. 

## Create a connector datasource

1. From the left-hand side go to **Administration** > **Data sources**

Click **add new** select the newly created connector, in this case the demo connector will be selected.

<img src="/images/connector-datasource.png" style="zoom:80%;border:1px solid black"/> 



2. Once the datasource is created you will see the datasource details screen, the buttons at the bottom are similar to any other datasource. The section in the middle is what can be customized using the settings UI and settings Code. 
    <img src="/images/Connector-datasource-created.png" style="zoom:100%; border:1px solid black"/>

  

## Create a microservice

Note that a microservice can be created in any programming language, the examples below are in c#, more languages will be added soon. 

### Requirements

The microservice should implement the following 3 functions.

1. Test
2. MetaData
3. Query

### Test 
The test function authenticates the user making the request and creates a token for any further requests to the datasource. 

The steps for the test function are as follows

1. Get the data from the [client connector request](#clientconnectorrequest) 

2. Decrypt the encrypted settings property bag using your secret key and the [Decrypt function](#decrypt-string-with-aes256)

3. Authorize the user and create bearer token using oauth for example

4. Add the oauth token to the settings property bag and [encrypt](#encrypt-string-with-aes256) using your secret key.

5. Create [client connector response](#clientconnectorresponse) and include success message to indicate test succeeded/failed.

6. Sign the response using the  [EncryptdatawithHMACSHA256 function](#encrypt-data-with-hmacsha256) and include in the client connector response. 

   Below shows an example connector test function from the Kianda demo microservice
```c#
 		[FunctionName("connectorTest")]
        public static async Task<ClientConnectorResponse> connectorTest(
            [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] [FromForm]HttpRequest req,
            ILogger log)
        {
            // { SubscriptionID, UserID, RequestID, Action, EncryptedSettingsPropertyBag, RequestObject}

            string signature = string.Empty;
            ClientConnectorResponse result = new ClientConnectorResponse();
            result.queryResult = new QueryResult();
            try
            {
                string testBody = await new StreamReader(req.Body).ReadToEndAsync();
                ClientConnectorRequest data = JsonConvert.DeserializeObject<ClientConnectorRequest>(testBody);
                var settings = JsonConvert.DeserializeObject<JObject>(DecryptStringWithAES256(SECRET_KEY, data.encryptedSettingsPropertyBag));
                var accessCode = settings["accessCode"];                 
                var clientID = settings["client_key"];
                JObject tokenRequestObj = new JObject
                {
                    ["grant_type"] = "authorization_code",
                    ["client_id"] = clientID,
                    ["redirect_uri"] = "https://app.kianda.com/index.html",
                    ["code"] = accessCode
                };
                settings = GetToken(tokenRequestObj, settings); //This is an example function that makes a request to oauth

                signature = EncryptDataWithHMACSHA256(SECRET_KEY, data.requestId); //sign using the secret key and requestid 
                var settingsobj = EncryptStringWithAES256(SECRET_KEY, JsonConvert.SerializeObject(settings)); //encrypt the settings
                result.encryptedSettingsPropertyBag = settingsobj;
                result.queryResult.signature = signature;
                result.queryResult.success = true;
                result.queryResult.message = "Test completed successfully";
            }
            catch (Exception ex) //dont forget to catch any exceptions and send them back with success false
            {
                log.LogError(ex.Message);
                ClientConnectorResponse result1 = new ClientConnectorResponse();
                result1.queryResult.success = false;
                result1.queryResult.signature=signature;
                result.queryResult.message = "Test has failed";
                return result1;
            }

            return result;
        }

```

### Metadata 

The metadata function provides the list of available endpoints in the microservice and is called when selecting the datasource in a kianda process.

The steps for the metadata function are as follows:

1. Get the client connector request 

2. Decrypt the encrypted settings property bag recieved in the request 

3. Create the Client connector response and include the tree 

   The following is an example of how to create the tree object in c#

```c#
List<JObject> CityFields = new List<JObject> { };

CityFields.Add(new JObject{["name"] = "Country", ["text"] = "Country", ["title"] = "Country", ["icon"] = "",["type"] = "text"});

CityFields.Add(new JObject { ["name"] = "City", ["text"] = "City", ["title"] ="City", ["icon"] = "", ["type"] = "text" });

List<JObject> CountryFields = new List<JObject> { };
CountryFields.Add(new JObject{["name"] = "Country", ["text"] = "Country", ["title"] = "Country",["icon"] = "",["type"]="text"});

List<JObject> nodes = new List<JObject> { };
nodes.Add(new JObject { ["name"] = "Get Countries", ["text"] = "Get Countries", ["title"] = "Get Countries", ["icon"] = "fa fa-globe", ["type"] = "STRUCTURE", ["nodes"] = new JArray { CountryFields }, ["fields"]=new JArray { CountryFields}, ["selectable"] = true });
nodes.Add(new JObject{ 
              ["name"] = "Get Cities", 
              ["text"] = "Get Cities", 
              ["title"] = "Get Cities", 
              ["icon"] = "fa fa-globe", 
              ["type"] = "STRUCTURE", 
              ["nodes"] = new JArray { CityFields }, 
              ["fields"] = new JArray { CityFields }, 
              ["selectable"] = true 
          });
//create the tree root to be returned
var root = new JObject {
["text"] = "Function",
["icon"] = "fa fa-bolt",
["nodes"] = new JArray { nodes }
};
```



The above code renders the following result

<img src="/images/example-tree-result.png"/>

### Query

The Query function is where the . 

The steps for the query function are as follows

1. Get the data from the [client connector request](#clientconnectorrequest) 

2. Decrypt the encrypted settings property bag using your secret key and the [Decrypt function](#decrypt-string-with-aes256)

3. Get the [query object](#query-1) from the request and call the function related to the query in the datasource. 

4. Create [client connector response](#clientconnectorresponse) and include success message to indicate query succeeded/failed.

5. Create the [query result](#queryresult) object and include in the response

6. Sign the response using the  [EncryptdatawithHMACSHA256 function](#encrypt-data-with-hmacsha256) and include in the client connector response. 

Below is a code sample of the connector query function, it includes a check for filters sent from the query and a response.

This is just sample code and a fully featured connector would include sperate functions where the query would be executed and return a response.

A user can query this function for the list of countries, list of cities or pass a filter value which will return a list of cities for a specific country.

```c#
        [FunctionName("connectorQuery")]
        public static async Task<ClientConnectorResponse> connectorQuery(
            [HttpTrigger(AuthorizationLevel.Function, "post", Route = null)] HttpRequest req,
            ILogger log)
        {
            ClientConnectorResponse result = new ClientConnectorResponse();
            QueryResult resultQuery = new QueryResult();
            result.queryResult = resultQuery;
            string signature = string.Empty;
            var myresponsestring = string.Empty;
            try
            {
                string testBody = await new StreamReader(req.Body).ReadToEndAsync();
                ClientConnectorRequest data = JsonConvert.DeserializeObject<ClientConnectorRequest>(testBody);
                Query query = data.query;
                var settings = JsonConvert.DeserializeObject<JObject>(DecryptStringWithAES256(SECRET_KEY, data.encryptedSettingsPropertyBag));
                //demo object list creation
                result.queryResult.items = new List<JObject>();
                if (query.info.Value<string>("text") == "Get Countries")
                {
                    List<JObject> CountriesList = new List<JObject>();
                    var country1 = new JObject { ["Country"] = "England" };
                    var country2 = new JObject { ["Country"] = "Ireland" };
                    CountriesList.Add(country1);
                    CountriesList.Add(country2);
                    result.queryResult.items = CountriesList;
                }
                else
                {
                    List<JObject> CitysList = new List<JObject>(); //create a list of jobjects 
                    var city1 = new JObject { ["Country"] = "England", ["City"] = "London" };
                    var city2 = new JObject { ["Country"] = "England", ["City"] = "Liverpool" };
                    var city3 = new JObject { ["Country"] = "Ireland", ["City"] = "Dublin" };
                    var city4 = new JObject { ["Country"] = "Ireland", ["City"] = "Cork" };
                    CitysList.Add(city1);
                    CitysList.Add(city2);
                    CitysList.Add(city3);
                    CitysList.Add(city4);

                    //check for conditions then return accordingly
                    if (query != null && !string.IsNullOrEmpty(query.filter))
                    {
                        //filtering the city list depending on the filter 
                        var j = CitysList.Where(x => x.GetValue("Country").Value<string>() == query.filter).ToList();
                        result.queryResult.items = j;
                    }
                    else
                    {
                        // if no filter return the full list of citys
                        result.queryResult.items = CitysList;
                    }
                }

                var settingsobj = EncryptStringWithAES256(SECRET_KEY, JsonConvert.SerializeObject(settings)); //encrypt the settings
                result.encryptedSettingsPropertyBag = settingsobj;
                result.signature = EncryptDataWithHMACSHA256(SECRET_KEY, data.requestId);
                result.queryResult.success = true;

            }
            catch (Exception ex)
            {
                ClientConnectorResponse resultExc = new ClientConnectorResponse();
                QueryResult resultQueryExc = new QueryResult();
                resultExc.queryResult.success = false;
                resultExc.queryResult.message = "Exception occured; " + ex.Message;
                resultExc.signature = signature;
                return resultExc;
            }

            return result;
        }
```




## Schemas

#### ClientConnectorRequest

Each function will receive a clientConnectorRequest payload.

Note, the Encrypted settings property bag will contain the encrypted datasource settings, it can only be decrypted using the secret key recieved when creating the client connector.

```c#
       public class ClientConnectorRequest
        {
            public string subscriptionId { get; set; }
            public string userId { get; set; }
            public string requestId { get; set; }
            public string action { get; set; }
            public string encryptedSettingsPropertyBag { get; set; }
            public Query query { get; set; }
        }


```
#### Query
The query object is included in the Client Connector Request

```c#
   public class Query {
        public string id { get; set; }
        public string action { get; set; }
        public JObject info { get; set; }
        public string orderBy { get; set; }
        public bool orderAscending { get; set; }
        public string paging { get; set; }
        public int rowLimit { get; set; }
        public List<string> fields { get; set; }
        public Dictionary<string, object> mappings { get; set; }
        public string filter { get; set; }
        public string filterBy { get; set; }
        public string filterMode { get; set; }
        public string signature { get; set; }

    }
```

#### ClientConnectorResponse

The Response again includes the encrypted settings property bag, the encrypt and decrypt functions are provided below. 

```c#
public class ClientConnectorResponse
    {
        public string requestId { get; set; }
        public string signature { get; set; }
        public string encryptedSettingsPropertyBag { get; set; }
        public QueryResult queryResult { get; set; }
    }
```
#### QueryResult
``` c#
public class QueryResult
        {
            public bool success { get; set; }
            public string message { get; set; }
            public JObject data { set; get; }
            public List<JObject> items { get; set; }
            public string resultCount { get; set; }
            public string signature { get; set; }
        }
```
The query result contains typical response paramaters, Note the signature string needs to be created using hmac for validation. 



## Encryption/Decryption Functions 

### Encrypt Data with HMACSHA256 


``` c#
private static string EncryptDataWithHMACSHA256(string key, string value)
        {
            using (var hash = new HMACSHA256(Encoding.UTF8.GetBytes(key)))
            {
                var hashedByte = hash.ComputeHash(Encoding.UTF8.GetBytes(value));
                var hashed = Convert.ToBase64String(hashedByte);
                return hashed;
            }
        }

```

### Decrypt String With AES256 

Since the settings property bag is encrypted and is sent with every request, a decryption function is provided below in C#

```c#
public static string DecryptStringWithAES256(string key, string cipherText) 
// Where key is the unique secret key recieved when creating the client connector and cipherText is the encryptedSettingsPropertBag
        {
            byte[] iv = new byte[16];
            byte[] buffer = Convert.FromBase64String(cipherText);

            using (Aes aes = Aes.Create())
            {
                aes.Key = Encoding.UTF8.GetBytes(key);
                aes.IV = iv;
                ICryptoTransform decryptor = aes.CreateDecryptor(aes.Key, aes.IV);

                using (MemoryStream memoryStream = new MemoryStream(buffer))
                {
                    using (CryptoStream cryptoStream = new CryptoStream((Stream)memoryStream, decryptor, CryptoStreamMode.Read))
                    {
                        using (StreamReader streamReader = new StreamReader((Stream)cryptoStream))
                        {
                            return streamReader.ReadToEnd();
                        }
                    }
                }
            }
        }
```

### Encrypt String With AES256 
```c#
public static string EncryptStringWithAES256(string key, string plainText)
        {
            byte[] iv = new byte[16];
            byte[] array;

            using (Aes aes = Aes.Create())
            {
                aes.Key = Encoding.UTF8.GetBytes(key);
                aes.IV = iv;

                ICryptoTransform encryptor = aes.CreateEncryptor(aes.Key, aes.IV);

                using (MemoryStream memoryStream = new MemoryStream())
                {
                    using (CryptoStream cryptoStream = new CryptoStream((Stream)memoryStream, encryptor, CryptoStreamMode.Write))
                    {
                        using (StreamWriter streamWriter = new StreamWriter((Stream)cryptoStream))
                        {
                            streamWriter.Write(plainText);
                        }

                        array = memoryStream.ToArray();
                    }
                }
            }

            return Convert.ToBase64String(array);
        }
```
## Security

 **AES256:** We use AES 256 to encrypt and decrypt to secure the data in the request and response so that even if the data is exposed, it cannot be decrypted without the right key. This is a symmetric encryption technique, which means the same key is used to encrypt and decrypt the data it is also a 2-way encryption algorithm.

<img src="/images/AES_encryption.png" style="zoom: 150%;" />



**HMAC:** We use HMAC to sign the signature to make sure the response is coming from the correct end point. HMAC is also an encryption algorithm but unlike AES it’s a one-way encryption, meaning it isn’t decrypted on the other side. It’s used for verification, for example if we encrypt with HMAC our secret key with a request id and then do the same in the response, we can verify that we have got the response back from the correct endpoint and it has not been tampered with because both hashes will match. HMAC stands for **H**ash based **M**essage **A**uthentication **C**ode and the hash used is SHA256. 

The main difference between the two is that AES we are encrypting and decrypting data, this is fast and secure for large data, with HMAC we use it to simultaneously verify both the data integrity and authenticity of a message.





<img src="/images/Sha256_Hashing.png" style="zoom:67%;" />

After creating the client connector and the datasource, the next step is to look at how the connector can be used.  



